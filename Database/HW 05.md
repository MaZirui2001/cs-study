# HW 05

PB20111623 马子睿

## 1

如果支持嵌套事务，可能会面临以下几个问题：

* 复杂性和开销增加：嵌套事务会增加数据库管理的复杂性，也就是说需要更多的操作才能处理嵌套事务以及嵌套事务的回滚；
* 死锁：在并发操作中，如果一个事务正在等待另一个事务锁定的资源，且又开启了一个新的嵌套事务，可能导致死锁；
* 数据不一致：如果一个嵌套事务回滚了一些更改，而外部事物继续提交，则可能导致数据不一致

## 2 

* 对于①，故障发生时还没有过检查点，这时需要做如下处理：

  * 正向扫描日志：
    * Redo列表：{T1}
    * Undo列表：{T2, T3}
  * 反向扫描日志，对于Undo列表：
    * T2：D = 45
    * T3：E = 20
    * T2：D = 20
    * T2：C = 20
  * 正向扫描日志，对于Redo列表
    * T1：A = 49
    * T1：B = 250
    * T1：A = 75
  * 写日志：
    * <Abort，T2>
    * <Abort， T3>

  执行恢复后：A = 75, B = 250, C = 20, D = 20, E = 20, F = 20, G = 20

* 对于②，故障发生时还没有过检查点，这时需要做如下处理：

  * 正向扫描日志：
    * Redo列表：{T1, T2, T3}
    * Undo列表：{}
  * 反向扫描日志，但Undo列表为空，不作操作
  * 正向扫描日志，对于Redo列表
    * T1：A = 49
    * T1：B = 250
    * T1：A = 75
    * T2：C = 35
    * T2：D = 45
    * T3：E = 55
    * T2：D = 46
    * T2：C = 65
  * 写日志：但此时没有不在Redo列表中的事务，不作操作

  执行恢复后：A = 75, B = 250, C = 65, D = 46, E = 55, F = 20, G = 20

* 对于③，故障发生时有一个检查点，这时忽视检查点之前的操作，做如下处理：

  * 正向扫描检查点后日志：
    * Redo列表：{}
    * Undo列表：{T4}
  * 反向扫描日志，对于Undo列表：
    * T4：F = 100
    * T4：G = 20
    * T4：F = 20
  * 正向扫描日志，由于Redo列表为空，不作操作
  * 写日志：
    * <Abort，T4>

  执行恢复后：A = 75, B = 250, C = 65, D = 46, E = 55, F = 20, G = 20

## 3

从序列中可以发现以下信息：如果冲突可串，那么：

* T4一定在T2之后（因为w2(A)早于r4(A)）
* T3一定在T2之后（因为w2(B)早于r3(B)）
* T4一定在T3之后（因为w3(B)早于r4(B)）
* T1一定在T3之后（因为w3(D)早于w1(D)）
* T2一定在T1之后（因为r1(A)早于w2(A)）

T2一定晚于T1，T1一定晚于T3，T3又一定晚于T2，出现矛盾，故不冲突可串

## 4

使用反证法：假设$S$是一个使用$2PL$得出的调度，且$S$并不冲突可串。那么由于$S$的非冲突可串性，事务的优先图中必须存在一个环，不妨假设这个环的构成为：$T_i\rightarrow T_k\rightarrow \dots \rightarrow T_i$。我们任取这个环中的两个事务$T_i \rightarrow T_j$，说明$T_i$中存在一个操作$a$​，$T_i$中存在一个操作$b$，这两个操作是冲突的，那么这两个操作至少有一个是写，且我们可以不妨假设$a$先于$b$，故可以得知，这两个操作所需要获取的锁一定是冲突的。

根据刚才的假设，$a$先获取了锁$l$ ，之后$b$也获取了锁$l$，证明$a$在$b$获取这把锁之前一定释放了这个锁。更进一步我们可以推知：$T_i$一定在$T_j$获取所有锁之前就开始释放锁。再推知，对于$T_j\rightarrow T_k$这两个事务，$T_j$一定在$T_k$获取所有锁之前就开始释放锁，那么$T_i$也一定在$T_k$获取所有锁之前就开始释放锁。之后我们根据这个环的路径继续推演，可以得到一个结论：$T_i$一定在$T_i$获取所有锁之前就开始释放锁，这是十分荒谬的，因为违背了$2PL$的定义，故出现矛盾，得证。

## 5

依然会出现脏读问题。假设事务T1需要修改A、B两个数据，先修改A后释放了A的锁，此时事务T2获取到了A的锁，并读取到了T1刚修改的值。但此时T1发生了问题导致回滚，T2就读取到了这个脏值。因此两阶段锁无法解决脏读问题。

