# 运行时空间管理与代码生成（选做）

> 负责助教：彭浩然

- [运行时空间管理与代码生成（选做）](#运行时空间管理与代码生成选做)
  - [简介](#简介)
  - [实验内容](#实验内容)
    - [任务1：寄存器分配](#任务1寄存器分配)
    - [任务2：Phi指令生成——数据移动](#任务2phi指令生成数据移动)
    - [任务3：栈空间分配](#任务3栈空间分配)
  - [提交要求](#提交要求)
    - [思考题](#思考题)
    - [实现思路](#实现思路)
    - [评测脚本要求](#评测脚本要求)
    - [参考文献（可选）](#参考文献可选)
  - [参考文档](#参考文档)

## 简介
这个实验中，你将完成在LLVM IR的基础上完成寄存器分配、Phi指令消除以及栈空间分配，最终得到可在实际机器上运行的汇编代码。LLVM IR虽然是一个整体而言靠近底层的中间表示，但是它仍有一些较为理想的假设和高层的语义，需要在代码生成阶段处理，包括
- 无限的虚拟寄存器
- Phi指令
- ...

无限寄存器的假设使得LLVM IR的代码不需要进行太多运行时的空间管理，比如栈的维护、临时寄存器的现场保存、汇编ABI接口的满足（如函数传参约定），所以在代码生成中需要添加这些部分的内容与相关信息的维护。

Phi指令虽然给代码优化过程提供了很多方便，但它的语义是非常高级的语义，它要求在代码执行的过程中感知代码执行路径，同时一个基本块开头的Phi指令并行执行，这基本没有硬件支持的基础，所以代码生成阶段要通过各种手段消除Phi指令。在本次实验中，Phi指令的消除方法是在代码生成阶段直接按照Phi指令的语义生成相关的数据移动代码。具体而言，对于中级IR（LLVM 兼容），每个基本块至多有两个后继，所以当执行到这个基本块的末尾，需要为它即将跳转到的基本块开头的Phi指令完成数据的移动，这部分代码在当前基本块末尾产生。对于有两个后继的分支跳转，可以使用ARM的条件执行指令产生代码，如下所示：

```
// code in LLVM IR
l0:
%3 = icmp ne i32 %1, i32 %2
br i1 %3, label %l1, label %l2

l1:
%4 = phi i32 [%1, %l0], [0, %l3]
...

l2:
%5 = phi i32 [%2, %l0], [1, %l3]
...


// code in asm, assuming that %1->r1, %2->r2, ...
l0:
    cmp r1, r2
    movne r4, r1
    bne l1
    mov r5, r2
    b l2
...
```

## 实验内容
本实验的基础要求以代码填空的形式给出，即，无需修改填空之外的内容即可得到一个功能正确的实现。但是，本实验也鼓励大家探索每一个任务的更优算法，允许使用非文档给出的算法，使得生成的代码运行更快或占用的存储空间更少。为了实现这些算法，你可以修改代码中的任何地方，但要后续在文档中说明。相比于追求数值上的调优，本实验更鼓励大家将精力投入到对不同算法的理解以及对不同情况下各种算法的优劣的讨论上。即使对大多数情形没有明显的优化，只要能给出触发优化的特定场景并做具体分析，也是对本实验的很好的完成。

实验之前请[阅读文档](#参考文档)，了解本实验框架给出的数据结构接口。本实验各个部分之间是相辅相成的，寄存器分配时候的策略（分配哪些寄存器，保留哪些寄存器）和栈空间的分配将直接影响后面实现的难易，同学们可以在这个过程中体会不同的设计选择之间的互相影响。

### 任务1：寄存器分配
在本部分，你需要补全一个线性扫描的寄存器分配算法。详情见[寄存器分配实验文档](RegAlloc.md)

### 任务2：Phi指令生成——数据移动
本实验框架提供的代码对于Phi指令的处理正如前面所述，需要你实现的是数据移动部分的代码，请在`./src/Backend/DataMoving.cpp`文件中补全`data_move`函数，它的定义如下：
- 参数`src`表示数据来源，它是一系列数据来源位置组成的`vector`，数据来源可能是立即数、寄存器或者栈上的地址；
- 参数`dst`表示数据目的地，它是一系列数据目的位置组成的`vector`，可能是寄存器或者栈地址，与`src`等长，源和目的按照在容器中的位置相对应；
- 参数`cmpop`表示条件执行所需条件，你编写的数据移动函数生成的所有数据指令都需要使用此条件执行

在实现过程中，你需要注意：
- 来源和目的有可能包含相同的寄存器或栈地址，但不一定是对应的，比如可能有如下输入：
  ```
  src = {r1,r2,r3}
  dst = {r2,r3,r1}
  ```
  按照Phi指令的语义，这些移动应该是并行执行，也就是说移动后 r1, r2, r3 三个寄存器中装的分别是 r3, r1, r2 在移动之前的值。你需要想办法解决这里的依赖问题，这也是这部分实验的重点。**欢迎各种奇思妙想**。
- 数据来源可能有重复，但目的地不会重复，来源有重复时，**寄存器和常数将是`IR2asm::RegLoc`类的不同对象，而栈地址将是`IR2asm::RegBase`的相同对象**，这是由于准备数据来源的时候没有检查是否重复，但栈地址是直接从`stack_map`中读出，所以相同的栈地址对应的是同一个对象。
- 对于有两个后继的基本块，本实验框架给出的Phi指令生成将会在分支指令成功和失败的跳转之前分别调用一次你写的数据移动函数，并传入条件执行所需要的条件，你不需要处理条件执行部分。
- 本实验框架已给出单个数据的移动代码(`single_data_move`)，它将单个源位置的数据移动到目的位置，同时附加条件码，你需要传入一个临时寄存器以完成将常数存入栈位置或将栈上数据移动到栈上另一位置。由于不做临时寄存器保护，当使用临时寄存器时`single_data_move`将**破坏临时寄存器的值**。
- 在本实验框架实现的代码生成部分，被调用者会在被调用时保存`lr`寄存器，退出前恢复`lr`寄存器的值，所以你可以使用`lr`，但是`single_data_move`有可能破坏`lr`寄存器的值（不论你传进什么临时寄存器），如果你要使用`lr`寄存器，请记得保存。

实验提示
- 需要防止破坏临时寄存器里的值，除非你确信这个寄存器是没用的，所以你可以在寄存器分配阶段就直接预留临时寄存器不分配出去。但是这种做法将导致可用寄存器变少，增大栈空间，而栈的数据移动是有些麻烦和费时的。
- 充分利用栈，这是一个非常大的连续内存空间，所以一个实现上简单处理数据相关的方法是把源全都压到栈上再逐个放到目的中去。这当然会产生性能损失，但因为本实验没有性能要求，所以用这种方法也是可以接受的。但我们仍希望你开动脑筋，尽力提高这部分的性能。

### 任务3：栈空间分配
由于LLVM IR有无限的虚拟寄存器，所以并没有显式地处理栈相关的操作，只是使用`alloca`来进行空间的分配。然而，实际体系结构中寄存器的数目是有限的，所以需要把一些寄存器放不下的内容溢出到栈上（包括数组）。
你需要在`./src/Bankend/StackAlloc.cpp`中实现栈空间分配的代码，请确保完成阅读[文档](#参考文档)后再写这部分代码，此函数以`Function*`为参数，代表待处理的函数，它的接口与你们之前实验的接口一致，通过这个指针你可以获得待处理函数的各种信息（如各个参数的信息、参数个数）。函数返回分配的总空间的大小（字节数）。

你需要注意：
- 寄存器分配产生的`reg_map`可以直接使用，它就是你在寄存器分配的时候生成的`reg_map`，你需要为其中`reg_num`为 -1 的`interval`分配栈空间，以`IR2asm::RegBase`给出其基地址，存入`stack_map`当中。
- 同时，通过栈传递的函数参数在栈上的位置（如ABI约定）还要保存到`arg_on_stack`当中，不论它是否被分配了寄存器。
- 你可以通过`bool have_temp_reg`和`bool have_func_call`来判断此函数是否使用临时寄存器以及内部是否有函数调用，它们都是`CodeGen`类的数据域。
- 类似的，你可以通过`int caller_saved_reg_num`和`int temp_reg_store_num`获得调用者保存的寄存器个数以及临时寄存器暂存空间的大小，通过`const int reg_size`来获得寄存器的字节数，它们都是`CodeGen`类的数据域并且已经在调用栈分配之前维护好。
- 注意函数形参的空间分配，有些参数通过栈传递，已经拥有了栈空间，不必重新分配。
- 局部数组并不在`reg_map`中，而是在开始块中通过`alloca`语句分配空间，所以你还需要遍历`fun->get_entry_block()->get_instructions()`，根据其中的`alloca`语句进行空间分配。
- 理论上讲你甚至可以将所有变量在寄存器分配阶段全部溢出到栈，这将使得寄存器分配的代码非常简单，但是代码将经历大量内存操作，这也属于设计选择互相影响的范畴。但是这种写法视为未完成寄存器分配。

## 提交要求

你的`answer.md`中应该包括下面的内容：

### 思考题

1. 由于指令长度有限，所以指令的立即数是有范围的。请查阅相关资料，了解在ARM的代码生成中如何处理超范围立即数问题，并在回答中进行说明。
2. 在本实验框架给出的IR实现中，可以通过强制给phi指令涉及到的所有虚寄存器分配相同的物理寄存器（或栈地址）来规避phi指令移动吗，为什么？
3. 如何在寄存器分配的时候结合函数调用ABI以及Phi指令的要求产生更高效率的代码？回答大体思路即可。

### 实现思路

描述你所使用的寄存器分配算法以及数据移动思路，以及你的实现区别于基本要求的任何亮点。

### 评测脚本要求

如果你实现了基本要求外的优化，并且需要通过特定样例体现优化效果，则请提供自动评测脚本[../test/student/build_asm.sh](../test/student/build_asm.sh)、[../test/student/run_exec.sh](../test/student/run_exec.sh) 与样例进行展示。该脚本将会在bash环境下执行。该测试脚本可驱动其他脚本(例如[../test/student/build_asm.py](../test/student/build_asm.py)等)，其他脚本也请放置在[../test/student/](../test/student/)目录下。请在脚本中自行添加在评测时需要用到的环境变量。**脚本中应采用相对路径，避免采用绝对路径**，因为提交的项目可能置于评测机的不同路径下。

学生编写的评测脚本运行时向stdout的输出将被收集作为待助教评判的内容。

自动评测脚本要求：

- [../test/student/build_asm.sh](../test/student/build_asm.sh) 需要能够驱动其他脚本，将你在[../test/student/](../test/student/)目录下放置所有用于评测的程序样例进行编译，并生成对应的汇编程序。为了体现对比效果，该脚本一般调用不同编译分析选项，生成基线程序和优化后程序。生成的汇编程序仍需要放置在该目录下，接下来这个文件夹将被自动评测脚本打包发送到树莓派上，解压并将当前工作目录设置为解压后的目录。该脚本执行在希冀平台环境中，架构为x86-64；具体逻辑可以参考[../test/student/build_asm.py](../test/student/build_asm.py)；
- [../test/student/run_exec.sh](../test/student/run_exec.sh) 需要能够驱动其他脚本，将你在[../test/student/](../test/student/)目录下放置的所有用于评测的汇编代码编译、链接运行时库，并生成可执行程序。该脚本需要执行可执行程序，并将基线程序和优化后程序的结果进行一定的解析、对比，输出到stdout中，供评测脚本收集、作为助教打分的标准。该脚本执行在树莓派上，架构为ARM，提供了python3.7.3环境；具体逻辑可以参考[../test/student/run_exec.py](../test/student/run_exec.py)；

在本机评测时，同学们可以先调用[../test/student/build_asm.sh](../test/student/build_asm.sh) 脚本生成汇编，再将整个[../test/student/](../test/student/)目录压缩打包上传到树莓派上，解压，再在树莓派对应目录上执行[../test/student/run_exec.sh](../test/student/run_exec.sh)脚本。

### 参考文献（可选）

如果参考了其他算法，请列出外部参考文献。

## 参考文档
[汇编指令相关数据结构定义接口](AsmValue.md)：在后端中，所有的位置（寄存器、立即数、栈地址等）使用助教提供的接口进行表示。

[栈帧结构与ABI约定](StackFrameAndABI.md)：在[栈空间分配](##栈空间分配)实验中，你需要按照约定进行栈空间分配。
