# Lab 1 Report

PB20111623 马子睿

## 流水线修改

### Bug修复

在Riscv中，分支（B-type）指令应当将PC+offset赋值给PC，而不是PC+4：

![image-20230406140705670](/home/madrid/.config/Typora/typora-user-images/image-20230406140705670.png)

原流水线中，分支地址计算使用了PC+4+offset，这是LC3系列使用的方法，所以我对流水线的这一部分进行了修改。

### 写回段修改

由于DataCache极有可能以组合的方式来送出数据（例如2周期流水Cache），这个数据再经过数据拓展模块后已经延迟相当大了。因此我选择将写回多选器放到WB段，而将ALU Out和Mem Data锁存一下，到WB段再进行选择。如此一来，可以很好的平衡流水级之间的时间延迟。

![image-20230406141149489](/home/madrid/.config/Typora/typora-user-images/image-20230406141149489.png)

### 地址计算修改

在原流水线中，将PC+4流水到后续流水级，从而导致了在EX段需要先减4再通过一系列多选器进入ALU。不过，这里会看到，减法器和ALU是串行的，因此这一部分的延迟就是：
$$
减法器+3选1多选器+ALU+2选1多选器
$$
由于第一处的Bug，我将所有的PC+4流水改为锁存PC，如此一来，需要将+4器放到Loadnpc控制的多选器之前，但这样就会让这个加法器和ALU是并行的，所以延迟变为：
$$
3选1多选器+ALU+2选1多选器
$$

（事实上还存在一种更好的设计：针对jalr，将计算跳转地址放到Branch Module中，而ALU只负责计算PC+4，这样的话，只需要将src2寄存器多一个+4选项，而延迟并没有增加（因为src1是3选1），同时就可以取消掉Loadnpc控制的多选器，这时计算jalr地址和ALU是并行的。不过如此一来当前数据通路不好表示（因为要在Branch Module中加入加法器），修改也比较多，所以后续问题答案并不是针对这种改进来回答的。）

**当前流水线的设计请见附件中的pdf文件**

## 问题回答

### Q1

* IF：取出这条XOR指令，并计算出PC+4，赋给PC寄存器
* ID：Control模块对指令进行译码，将ALU Func信号设置为异或，Op1和Op2都设置为“取寄存器中数值”，同时生成寄存器堆写使能有效，LoadNPC为“选择ALU Out”， WB Select为“选择ALU Out”，其余信号全部无效或为0。
* EX：此时有可能需要通过Forward前递数据，ALU执行了两个寄存器数据（可能是前递来的）的异或运算，同时LoadNPC应选择ALU Out
* MEM：这一阶段由于不涉及访存，故没有任何行为
* WB：通过WB Select信号的控制，多选器最终将ALU运算结果写回寄存器堆

### Q2

* IF：取出这条BEQ指令，并计算出PC+4，赋给PC寄存器
* ID：Control模块对指令进行译码，Op1和Op2都设置为“取寄存器中数值”，通过func3，将brtype设置为“相等”，并标识当前指令为跳转有效，基于Btype指令生成好立即数，并计算好跳转地址。其余信号全部无效或为0。
* EX：此时有可能需要通过Forward前递数据，将这两个“寄存器”数据送入Branch Module，执行PC的跳转，并生成flush指令，冲刷掉IF-ID寄存器和ID-EX寄存器。
* MEM：这一阶段由于不涉及访存，故没有任何行为
* WB：BEQ的寄存器写使能是无效的，因此这里也没有任何行为

### Q3

* IF：取出这条LHU指令，并计算出PC+4，赋给PC寄存器
* ID：Control模块对指令进行译码，Op1设置为“取寄存器中数值”，Op2设置为“取立即数”，通过func3，将Load TypeM设置为“加载无符号半字”，LoadNPC设置为“选择ALU Out”，基于Itype指令生成好立即数，寄存器堆写使能设置为有效，WB Select设置为选择Mem Data。其余信号全部无效或为0。
* EX：此时有可能需要通过Forward前递数据，且如果后一条指令与本LHU指令存在写后读的load-use相关，需要通过Hazard模块生成一个气泡（PC和IF-ID寄存器停顿一周期，冲刷ID-EX寄存器），ALU负责计算访存地址。
* MEM：通过地址向DCache发起访存，读出数据经过地址和Load TypeM的控制移位为正确的数据，存入MEM-WB寄存器
* WB：WB Select选择Mem Data作为写回数据，将数据写回寄存器堆

### Q4

如果添加CSR读写指令，流水线中应当增加：

1. CSR寄存器堆：这一部分放到ID段中，每一个寄存器都是写优先的
2. Prev特权指令处理模块：这一部分放到EX段中，由于CSR只可能通过简单的计算来更新，因此**输出结果可以直接送回CSR寄存器堆中**，如此一来就解决了所有CSR的相关问题
3. CSR读取的数据应当在EX段与ALU的结果、NPC进行一次选择，这个选择信号由Control生成，这样就解决了所有的前递问题。当然，这个CSR读数据也可以在EX段锁存一级，到MEM段再和ALU的结果、NPC做选择，以避免更大的延迟（因为存储访问延迟是更大的）

### Q5

* 零拓展：Verilog默认进行零拓展，不过如果用较小位宽的信号连接到大位宽的接口上，可能会造成RTL warning。当然，零拓展也可以用位拼接，高位拼0即可
* 位拓展：可以使用$signed(num)标记进行有符号拓展。当然也可以使用位拼接，高位拼当前最高位即可

### Q6

* Load：只需在读出数据后，根据末两位地址和访存类型对读出数据进行移位即可，具体可参考如下chisel代码：

  ```scala
      switch(mem_access) {
          is(LOAD_B)  { mem_rdata := Cat(Fill(56, load_b(7)), load_b) }
          is(LOAD_UB) { mem_rdata := load_b }
          is(LOAD_H)  { mem_rdata := Cat(Fill(48, load_h(15)), load_h) }
          is(LOAD_UH) { mem_rdata := load_h }
          is(LOAD_W)  { mem_rdata := Cat(Fill(32, load_w(31)), load_w) }
          is(LOAD_UW) { mem_rdata := load_w }
          is(LOAD_D)  { mem_rdata := rdata } 
      } 
  ```

  当然，在位移的时候，也应当注意符号位拓展和无符号拓展的问题

* Store：存储操作需要硬件的支持，高速缓存存储器应当开启字节写使能或位写使能。在送入存储器之前，也应当根据高速缓存的行宽来生成一个可写的数据。一个简单的方法是：把当前要写的数据复制到高位（写字节，就把高24位复制成3个低8位；写半字，就把高16位复制成低16位），通过控制字节写使能，来完成写操作。

### Q7

默认wire变量都是无符号数，因此在执行有符号运算的时候（例如算数右移），需要加上$signed()标记

### Q8

BR信号用来控制将一条分支（Btype）指令的跳转地址通过NPC Generator MUX写入PC寄存器

### Q9

有优先级。JAL指令是在ID阶段跳转，而Branch和JALR指令是在EX阶段跳转。BR和JALR指令不会出现冲突（因为同一时间EX阶段只能有一条指令），但很有可能Branch或JALR指令后接一条JAL指令。由于这条JAL指令可能是由于分支指令没有来得及跳转而取出的，因此JALR的Branch的跳转优先级应当高于JAL

### Q10

* Load-Use冲突：需要在load之后插入一个气泡，流水线需要停顿一个周期
* 跳转冲突：JAL指令会带来一个气泡，流水线事实上没有真正“停顿”，而是被冲刷了一条指令，相当于停顿一个周期。JALR和分支指令在EX段跳转，流水线被冲刷了两条指令，相当于停顿了两个周期

### Q11

在EX段遇到branch指令且需要跳转时，需要将FlushD和FlushE置位1个周期，stall信号无需处理

### Q12

会产生影响，因为0号寄存器始终是0，所有写入其中的数据都不应被前递或写优先。这里事实上有两种方法解决：

1. 在前递模块中做判断：如果目的寄存器是0，则不前递。不过这样会让本来就跨流水级的前递时序变差
2. 在译码模块，如果目的寄存器是0，那么直接不生成寄存器写信号（因为写0号寄存器本来就不会对流水线状态产生任何影响，而前递模块是需要通过看当前前递指令是写寄存器才能前递，所以不需要对前递模块做任何改动）